"""
L4 Lagrange Point Simulation Visualizer

This script reads simulation data generated by 'lagrange_point.cpp'
(or a similar program) and creates a multi-panel animation visualizing
the motion of a test particle near the Sun-Earth L4 Lagrange point.

It displays three views:
1. An animated main view showing the Sun, Earth, and test particle motion.
2. An animated zoomed-in view centered near the initial L4 position.
3. A static view showing the complete trajectories of all bodies.

The simulation data file ('L4_output.txt' by default) should have:
- Row 1: Header comment (ignored)
- Subsequent rows: Time(days) SunX SunY EarthX EarthY TestX TestY ...

Dependencies: matplotlib, numpy
"""
# Import necessary libraries
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.animation as animation
import sys

# --- Configuration Constants ---

# Input file generated by the C++ simulation
OUTPUT_FILENAME = "L4_output.txt"

# Indices for accessing body data after parsing (0-based)
SUN_INDEX = 0
EARTH_INDEX = 1
TEST_PARTICLE_INDEX = 2 # Assumed to be the third body

# Plotting Style and Parameters
BASE_COLORS = ["yellow", "blue", "red", "green", "purple", "orange"] # Default colors for bodies
FIGURE_BG_COLOR = 'black'   # Figure background color
AXES_BG_COLOR = 'black'     # Axes background color
GRID_COLOR = 'gray'         # Grid line color
TEXT_COLOR = 'white'        # Text color (titles, labels, ticks)
SPINE_COLOR = 'white'       # Axes border (spine) color
L4_MARKER_COLOR = 'cyan'    # Color for the 'L4' text marker

# Animation Parameters
TARGET_ANIMATION_DURATION_S = 20  # Aim for this total animation duration (seconds)
MP4_FILENAME = 'l4_animation.mp4' # Filename if saving animation
SAVE_ANIMATION = False            # Set to True to save animation

# Plot Limits
# Main plot shows the whole Sun-Earth system roughly
MAIN_PLOT_LIMIT = 1.6e11 # +/- limit in meters (slightly larger than 1 AU)
# Inset plot zooms in on the L4 region
INSET_ZOOM_RANGE = 1.5e10 # +/- range around initial L4 position for zoom (meters)

# --- Functions ---

def load_simulation_data(filename=OUTPUT_FILENAME):
    """
    Loads simulation data from the specified text file.

    Args:
        filename (str, optional): Path to the input data file.
                                  Defaults to OUTPUT_FILENAME.

    Returns:
        numpy.ndarray: A 2D numpy array containing the loaded data.
                       Exits script on error (file not found, format error).
    """
    try:
        # Load data, automatically skipping lines starting with '#'
        data = np.loadtxt(filename, comments='#')
        print(f"Successfully loaded data from '{filename}' with shape {data.shape}")
        # Handle case where only one time step is present
        if data.ndim == 1:
             data = data.reshape(1, -1)
        return data
    except FileNotFoundError:
        print(f"Error: Output file '{filename}' not found.")
        print("Please ensure the C++ simulation ('lagrange_point.cpp') has been run successfully.")
        sys.exit(1)
    except ValueError:
        # Catches errors if data isn't purely numeric or has wrong delimiters
        print(f"Error: Could not read numerical data from '{filename}'.")
        print("Check file format/content. Ensure it's space-separated numbers and matches expected columns.")
        sys.exit(1)
    except Exception as e:
        print(f"An unexpected error occurred loading '{filename}': {e}")
        sys.exit(1)

def validate_data_format(data):
    """
    Validates the shape/format of the loaded data array.

    Args:
        data (numpy.ndarray): The loaded simulation data.

    Returns:
        int: The number of bodies detected based on the column count.
             Exits script if format is invalid.
    """
    # Expected columns: 1 (Time) + num_bodies * 2 (X, Y)
    min_expected_columns = 1 + 2 * 3 # Time + Sun(x,y) + Earth(x,y) + Test(x,y)
    num_cols = data.shape[1]

    # Check if column count is at least the minimum and follows the 1 + 2*N pattern
    if num_cols < min_expected_columns or (num_cols - 1) % 2 != 0:
        print(f"Error: Unexpected number of columns ({num_cols}).")
        print("Expected format: Time SunX SunY EarthX EarthY TestX TestY [...]")
        print(f"(Requires at least {min_expected_columns} columns, and column count must be odd)")
        sys.exit(1)

    # Calculate number of bodies from columns
    num_bodies = (num_cols - 1) // 2
    print(f"Data format validated: Found {num_bodies} bodies.")
    return num_bodies

def calculate_relative_trajectories(data, num_bodies):
    """
    Extracts time data and calculates trajectories relative to the first body (Sun).

    Args:
        data (numpy.ndarray): The loaded simulation data.
        num_bodies (int): The number of bodies detected.

    Returns:
        tuple: A tuple containing:
            - time_data (numpy.ndarray): 1D array of time steps.
            - relative_trajectories (dict): Dictionary where keys are body indices (0-based)
                                            and values are tuples of (x_relative_array, y_relative_array).
            - body_indices (dict): Maps body names ('sun', 'earth', 'test') to their original column indices.
    """
    time_data = data[:, 0] # First column is time
    # Get Sun's absolute trajectory (index 0) to use as reference
    sun_x = data[:, 1 + 2 * SUN_INDEX]
    sun_y = data[:, 2 + 2 * SUN_INDEX]

    relative_trajectories = {}
    body_indices = {'sun': 1, 'earth': 3, 'test': 5} # Store original base column indices

    print("Calculating trajectories relative to the Sun (Body 0)...")
    for i in range(num_bodies):
        # Calculate column indices for current body's X and Y data
        x_col_index = 1 + 2 * i
        y_col_index = 2 + 2 * i
        # Extract absolute X and Y
        x_abs = data[:, x_col_index]
        y_abs = data[:, y_col_index]
        # Calculate relative trajectory by subtracting Sun's position
        x_rel = x_abs - sun_x
        y_rel = y_abs - sun_y
        # Store the relative trajectory arrays in the dictionary
        relative_trajectories[i] = (x_rel, y_rel)

    return time_data, relative_trajectories, body_indices

def setup_figure_axes():
    """
    Creates the main figure and the three subplots (axes).

    Returns:
        tuple: (matplotlib.figure.Figure, tuple_of_axes)
    """
    print("Setting up plot figure and axes...")
    # Create a figure with 1 row, 3 columns of subplots
    fig, axes = plt.subplots(1, 3, figsize=(24, 8))
    fig.patch.set_facecolor(FIGURE_BG_COLOR)
    return fig, axes

def configure_plot_axes(ax, title, x_lim, y_lim, xlabel="X Position (Rel. to Sun, m)", ylabel="Y Position (Rel. to Sun, m)"):
    """
    Configures the appearance of a single subplot axes.

    Args:
        ax (matplotlib.axes.Axes): The axes object to configure.
        title (str): The title for the subplot.
        x_lim (tuple): Tuple containing (min_x, max_x) limits.
        y_lim (tuple): Tuple containing (min_y, max_y) limits.
        xlabel (str, optional): Label for the x-axis.
        ylabel (str, optional): Label for the y-axis.
    """
    ax.set_xlim(x_lim)
    ax.set_ylim(y_lim)
    ax.set_xlabel(xlabel)
    ax.set_ylabel(ylabel)
    ax.set_title(title)
    ax.grid(True, color=GRID_COLOR, linestyle='--', linewidth=0.5)
    ax.set_facecolor(AXES_BG_COLOR)

    # Set colors for text elements
    ax.tick_params(axis='x', colors=TEXT_COLOR)
    ax.tick_params(axis='y', colors=TEXT_COLOR)
    ax.xaxis.label.set_color(TEXT_COLOR)
    ax.yaxis.label.set_color(TEXT_COLOR)
    ax.title.set_color(TEXT_COLOR)

    # Set color for axes borders
    for spine in ax.spines.values():
        spine.set_edgecolor(SPINE_COLOR)

    # Ensure aspect ratio is equal (circles look like circles)
    ax.set_aspect('equal', adjustable='box')

def plot_static_trajectories(ax_static, relative_trajectories, colors):
    """
    Plots the full trajectories for all bodies on the static axes subplot.

    Also adds markers for the start ('o') and end ('x') points.

    Args:
        ax_static (matplotlib.axes.Axes): The axes for the static plot.
        relative_trajectories (dict): Dictionary of relative trajectory data.
        colors (list): List of colors to use for each body.

    Returns:
        list: A list of all artists added to the static plot (lines, markers).
    """
    num_bodies = len(relative_trajectories)
    static_artists = []
    body_labels = ["Sun (Origin)", "Earth", "Test Particle"] # Labels for legend

    print("Plotting full static trajectories...")
    for i in range(num_bodies):
        # Marker for the Sun
        if i == SUN_INDEX:
            sun_marker, = ax_static.plot(0, 0, 'o', color=colors[i % len(colors)], markersize=8, label=body_labels[i])
            static_artists.append(sun_marker)
            continue

        x_full, y_full = relative_trajectories[i]
        label = body_labels[i] if i < len(body_labels) else f"Body {i}"
        color = colors[i % len(colors)]

        # Plot the full trajectory line
        line, = ax_static.plot(x_full, y_full, '-', color=color, linewidth=1, alpha=0.8, label=label)
        static_artists.append(line)
        # Plot start marker
        start_marker, = ax_static.plot(x_full[0], y_full[0], 'o', color=color, markersize=6)
        static_artists.append(start_marker)
        # Plot end marker
        end_marker, = ax_static.plot(x_full[-1], y_full[-1], 'x', color=color, markersize=8, markeredgewidth=2)
        static_artists.append(end_marker)

    # Add legend to the static plot
    ax_static.legend(facecolor=AXES_BG_COLOR, edgecolor=SPINE_COLOR, labelcolor=TEXT_COLOR, fontsize='small')
    return static_artists

def initialize_animated_artists(ax_main, ax_inset, num_bodies, colors):
    """
    Initializes the plot artists (lines and points) for the animated subplots.

    Creates empty plot objects that will be updated in each animation frame.

    Args:
        ax_main (matplotlib.axes.Axes): The main animated axes.
        ax_inset (matplotlib.axes.Axes): The inset (zoomed) animated axes.
        num_bodies (int): The number of bodies to animate.
        colors (list): List of colors for each body.

    Returns:
        tuple: Four lists containing the line and point artists for main and inset plots:
               (lines_main, points_main, lines_inset, points_inset)
    """
    lines_main = []
    points_main = []
    lines_inset = []
    points_inset = []
    body_labels = ["Sun (Origin)", "Earth", "Test Particle"] # Labels for main plot legend

    print("Initializing animated plot elements...")
    for i in range(num_bodies):
        label = body_labels[i] if i < len(body_labels) else f"Body {i}"
        color = colors[i % len(colors)]

        # Create empty line and point for the main plot
        # Add labels only to main plot elements for the legend
        line, = ax_main.plot([], [], '-', color=color, linewidth=1, label=f"{label} Path")
        point, = ax_main.plot([], [], 'o', color=color, markersize=(8 if i==SUN_INDEX else 5), label=f"{label} Pos")
        lines_main.append(line)
        points_main.append(point)

        # Create empty line and point for the inset plot
        line_inset, = ax_inset.plot([], [], '-', color=color, linewidth=1)
        point_inset, = ax_inset.plot([], [], 'o', color=color, markersize=(8 if i==SUN_INDEX else 5))
        lines_inset.append(line_inset)
        points_inset.append(point_inset)

    # Add legend to the main animated plot
    ax_main.legend(facecolor=AXES_BG_COLOR, edgecolor=SPINE_COLOR, labelcolor=TEXT_COLOR, fontsize='small', loc='upper right')
    return lines_main, points_main, lines_inset, points_inset

# Global dictionary to hold references to animated artists for easy access in update function
animated_artists = {}

def update_animation(frame, time_data, relative_trajectories, num_bodies):
    """
    Update function called by FuncAnimation for each frame.

    Updates the data for lines and points in both animated plots and the time text.

    Args:
        frame (int): The current frame index.
        time_data (numpy.ndarray): Array of time values.
        relative_trajectories (dict): Dictionary of relative trajectory data.
        num_bodies (int): Number of bodies.

    Returns:
        list: A list of artists that were modified in this frame (required for blitting).
    """
    artists_to_return = [] # List of artists updated in this frame

    for i in range(num_bodies):
        # Get the full trajectory for the current body
        x_traj, y_traj = relative_trajectories[i]

        # Safety check for frame index
        if frame >= len(x_traj):
             print(f"Warning: Frame index {frame} out of bounds for trajectory data (length {len(x_traj)}). Skipping update for body {i}.")
             continue # Skip update for this body if frame is out of bounds

        # Get the current position for this frame
        current_x = x_traj[frame]
        current_y = y_traj[frame]

        # Update main plot
        animated_artists['lines_main'][i].set_data(x_traj[:frame+1], y_traj[:frame+1])
        animated_artists['points_main'][i].set_data([current_x], [current_y])
        artists_to_return.extend([
            animated_artists['lines_main'][i], animated_artists['points_main'][i]
        ])

        # Update inset plot
        animated_artists['lines_inset'][i].set_data(x_traj[:frame+1], y_traj[:frame+1])
        animated_artists['points_inset'][i].set_data([current_x], [current_y])
        artists_to_return.extend([
            animated_artists['lines_inset'][i], animated_artists['points_inset'][i]
        ])

    # Update the time text display
    current_time_days = time_data[frame]
    animated_artists['time_text'].set_text(f'Time: {current_time_days:.2f} days')
    artists_to_return.append(animated_artists['time_text'])

    # Ensure L4 text markers are included in the returned list
    if 'L4_label' in animated_artists:
        artists_to_return.append(animated_artists['L4_label'])
    if 'L4_label_inset' in animated_artists:
        artists_to_return.append(animated_artists['L4_label_inset'])

    return artists_to_return

def main():
    """
    Main execution function: loads data, sets up plots, runs animation.
    """
    # --- Data Loading and Processing ---
    data = load_simulation_data()
    num_bodies = validate_data_format(data)
    time_data, relative_trajectories, body_indices = calculate_relative_trajectories(data, num_bodies)
    num_frames = len(time_data) # Total number of animation frames

    # --- Setup Colors ---
    # Assign colors to bodies, cycling through BASE_COLORS if needed
    colors = BASE_COLORS[:num_bodies]
    if num_bodies > len(BASE_COLORS):
        # Extend colors list by cycling through base colors if more bodies than colors
        colors.extend(BASE_COLORS[i % len(BASE_COLORS)] for i in range(len(BASE_COLORS), num_bodies))

    # --- Setup Figure and Axes ---
    fig, (ax_main, ax_inset, ax_static) = setup_figure_axes()

    # --- Determine L4 Position for Zoom and Marker ---
    # Use the initial position of the test particle as the approximate L4 location
    initial_l4_pos = (0.0, 0.0) # Default if test particle not found
    if TEST_PARTICLE_INDEX < num_bodies:
        try:
            initial_l4_pos = (
                relative_trajectories[TEST_PARTICLE_INDEX][0][0], # Initial rel x of test particle
                relative_trajectories[TEST_PARTICLE_INDEX][1][0]  # Initial rel y of test particle
            )
            print(f"Initial relative L4 position (for zoom/marker): ({initial_l4_pos[0]:.3e}, {initial_l4_pos[1]:.3e})")
        except IndexError:
            print("Warning: Could not get initial L4 position from trajectory data. Using (0,0).")
    else:
        print(f"Warning: Test particle index ({TEST_PARTICLE_INDEX}) >= num_bodies ({num_bodies}). Using (0,0) for L4.")

    # --- Configure Axes Limits and Titles ---
    # Configure the main animated plot
    configure_plot_axes(ax_main, "Animated Orbital Motion (Centered on Sun)",
                        (-MAIN_PLOT_LIMIT, MAIN_PLOT_LIMIT), (-MAIN_PLOT_LIMIT, MAIN_PLOT_LIMIT))
    # Configure the static trajectory plot
    configure_plot_axes(ax_static, "Full Trajectories (Static)",
                        (-MAIN_PLOT_LIMIT, MAIN_PLOT_LIMIT), (-MAIN_PLOT_LIMIT, MAIN_PLOT_LIMIT))
    # Configure the inset (zoomed) animated plot centered around initial L4 position
    configure_plot_axes(ax_inset, f"L\u2084 Region Zoom (Animated)", # Using unicode subscript 4
                        (initial_l4_pos[0] - INSET_ZOOM_RANGE, initial_l4_pos[0] + INSET_ZOOM_RANGE),
                        (initial_l4_pos[1] - INSET_ZOOM_RANGE, initial_l4_pos[1] + INSET_ZOOM_RANGE))

    # --- Plot Static Elements ---
    plot_static_trajectories(ax_static, relative_trajectories, colors)

    # --- Initialize Animated Elements ---
    # Create the plot objects (lines, points) for animation
    lines_main, points_main, lines_inset, points_inset = initialize_animated_artists(
        ax_main, ax_inset, num_bodies, colors
    )
    # Store references to these artists in the global dictionary for the update function
    animated_artists['lines_main'] = lines_main
    animated_artists['points_main'] = points_main
    animated_artists['lines_inset'] = lines_inset
    animated_artists['points_inset'] = points_inset

    # Add L4 text marker if test particle exists
    if TEST_PARTICLE_INDEX < num_bodies:
        # Add 'L4' text annotation near the initial L4 position in both animated plots
        animated_artists['L4_label'] = ax_main.text(
            initial_l4_pos[0], initial_l4_pos[1], "L\u2084", # Unicode subscript 4
            fontsize=12, color=L4_MARKER_COLOR, ha='center', va='bottom'
        )
        animated_artists['L4_label_inset'] = ax_inset.text(
             initial_l4_pos[0], initial_l4_pos[1], "L\u2084",
             fontsize=12, color=L4_MARKER_COLOR, ha='center', va='bottom'
        )

    # Add time text display to the main plot
    animated_artists['time_text'] = ax_main.text(
        0.02, 0.95, '', transform=ax_main.transAxes, # Position relative to axes boundaries
        fontsize=12, color=TEXT_COLOR, ha='left'
    )

    # --- Setup and Run Animation ---
    interval_ms = max(1, int((TARGET_ANIMATION_DURATION_S * 1000) / num_frames))
    print(f"Starting animation: {num_frames} frames, Interval: {interval_ms} ms, Target Duration: {TARGET_ANIMATION_DURATION_S}s.")

    # Create the FuncAnimation object
    ani = animation.FuncAnimation(
        fig=fig,                       # Figure to animate
        func=update_animation,         # Function to call for each frame
        frames=num_frames,             # Number of frames to run
        fargs=(time_data, relative_trajectories, num_bodies), # Extra arguments for update_animation
        interval=interval_ms,          # Delay between frames in ms
        blit=True,                     # Using blitting for faster rendering
        repeat=False                   # Whether to loop the animation or not
    )

    # Adjust layout to prevent titles/labels overlapping and display the plot window
    plt.tight_layout(rect=[0, 0.03, 1, 0.95])
    plt.show()

    # --- Save Animation ---
    if SAVE_ANIMATION:
        try:
            print(f"Saving animation to '{MP4_FILENAME}'... (this may take time)")
            # Use ffmpeg writer to save as MP4
            ani.save(MP4_FILENAME, writer='ffmpeg', fps=30, dpi=150,
                     progress_callback=lambda i, n: print(f'Saving frame {i+1}/{n}', end='\r', flush=True)) # Show progress
            print(f"\nAnimation saved successfully to '{MP4_FILENAME}'.")
        except Exception as e:
            print(f"\nError saving animation: {e}")

# --- Main Execution Guard ---
if __name__ == "__main__":
    # This ensures the main function runs only when the script is executed directly
    main()