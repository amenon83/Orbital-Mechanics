"""
Cassini Division Simulation Visualizer

This script reads simulation data generated by 'cassini_division.cpp'
(or a similar program) and creates an animation visualizing the motion
of test particles in the Saturn-Mimas system, demonstrating the clearing
of the Cassini Division due to orbital resonance.

The simulation data file ('cassini_output.txt' by default) should have:
- Row 1: Header comment (ignored)
- Row 2: Header comment (ignored)
- Row 3: Column names comment: # Time(s) P0_x(m) P0_y(m) P1_x(m) P1_y(m) ...
- Subsequent rows: Time followed by x, y coordinates for each particle.

Dependencies: matplotlib, numpy
"""

# Import necessary libraries
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import numpy as np
import matplotlib.animation as animation
import sys
import os

# --- Configuration Constants ---

# Input file generated by the C++ simulation
INPUT_FILENAME = "cassini_output.txt"

# Physical Constants
G = 6.67430e-11  # Gravitational constant (m^3 kg^-1 s^-2)

# Saturn System Approximate Radii/Distances (meters)
SATURN_RADIUS_APPROX = 6.0268e7  # Approximate radius of Saturn's visible body
MIMAS_ORBIT_RADIUS = 1.85539e8    # Semi-major axis of Mimas' orbit (= 'a' in simulation)
CASSINI_INNER_R = 1.1758e8       # Approximate inner edge of Cassini Division
CASSINI_OUTER_R = 1.2217e8       # Approximate outer edge of Cassini Division
# Calculated radius of the 2:1 mean-motion resonance with Mimas
RESONANCE_2_1_R = MIMAS_ORBIT_RADIUS * (0.5**(2.0/3.0))

# Plotting Parameters
PLOT_LIMIT = 2.0e8          # Extents of the plot axes (+/- PLOT_LIMIT meters)
PARTICLE_SIZE = 0.5         # Size of the scatter plot points representing particles
FIGURE_BG_COLOR = 'black'   # Background color of the figure window
AXES_BG_COLOR = 'black'     # Background color of the plot area
GRID_COLOR = 'dimgray'      # Color of the grid lines (if enabled)
TEXT_COLOR = 'white'        # Color for text elements (title, labels, ticks)
SATURN_COLOR = 'lightgoldenrodyellow' # Color for Saturn's representation
MIMAS_ORBIT_COLOR = 'cornflowerblue' # Color for Mimas' orbital path
CASSINI_COLOR = 'firebrick'      # Color for Cassini Division boundaries
RESONANCE_COLOR = 'lime'         # Color for the 2:1 resonance circle

# Animation Parameters
SAVE_ANIMATION = False             # Set to True to save the animation as an MP4 file
# Target duration of the output animation in seconds (adjusts frame interval)
TARGET_ANIMATION_DURATION_S = 30
MP4_FILENAME = 'cassini_clearing_animation.mp4' # Filename if saving

# --- Functions ---

def load_data(filename):
    """
    Loads simulation data from the specified text file.

    Args:
        filename (str): The path to the input data file.

    Returns:
        numpy.ndarray: A 2D numpy array containing the loaded data.
                       Exits script if file not found or loading fails.
    """
    if not os.path.exists(filename):
        print(f"Error: Input file '{filename}' not found.")
        sys.exit(1)  # Exit if the input file doesn't exist
    try:
        print(f"Loading data from '{filename}'...")
        # Load data, skipping header comment lines if they start with '#'
        data = np.loadtxt(filename, comments='#')
        print(f"Data loaded successfully with shape: {data.shape}")
        # Handle case where only one time step is present
        if data.ndim == 1:
             data = data.reshape(1, -1)
        return data
    except Exception as e:
        print(f"Error loading data from '{filename}': {e}")
        sys.exit(1) # Exit on loading error

def parse_data(data):
    """
    Parses the loaded data array into time and particle position arrays.

    Args:
        data (numpy.ndarray): The 2D numpy array loaded from the file.

    Returns:
        tuple: A tuple containing:
            - time_data (numpy.ndarray): 1D array of time steps.
            - particle_data (numpy.ndarray): 3D array of particle positions
                                             (time, particle_index, [x, y]).
            - num_particles (int): The number of particles found in the data.
            Exits script if the number of columns is inconsistent.
    """
    time_data = data[:, 0]  # First column is time
    num_cols = data.shape[1]

    # Validate the number of columns: 1 time + N particles * 2 coordinates
    if (num_cols - 1) % 2 != 0:
        print(f"Error: Unexpected number of columns ({num_cols}). "
              f"Should be 1 (time) + 2*N (particles). Check '{INPUT_FILENAME}'.")
        sys.exit(1) # Exit if columns don't match expected format

    num_particles = (num_cols - 1) // 2
    print(f"Found data for {num_particles} particles.")

    # Reshape the remaining columns into (time_steps, num_particles, 2_coordinates)
    particle_data = data[:, 1:].reshape(len(time_data), num_particles, 2)
    return time_data, particle_data, num_particles

def plot_reference_circles(ax):
    """
    Adds reference circles to the plot axes.

    Draws circles representing Saturn's approximate size, Mimas' orbit,
    the approximate boundaries of the Cassini Division, and the location
    of the 2:1 orbital resonance with Mimas.

    Args:
        ax (matplotlib.axes.Axes): The axes object to plot on.
    """
    # Create Circle patches for each reference object
    saturn = plt.Circle((0, 0), SATURN_RADIUS_APPROX, color=SATURN_COLOR,
                        fill=True, alpha=0.6, label='Saturn (approx.)')
    mimas_orbit = plt.Circle((0, 0), MIMAS_ORBIT_RADIUS, color=MIMAS_ORBIT_COLOR,
                             fill=False, linestyle=':', linewidth=1, label='Mimas Orbit')
    cassini_inner = plt.Circle((0, 0), CASSINI_INNER_R, color=CASSINI_COLOR,
                               fill=False, linestyle='--', linewidth=0.8, label='Cassini Div. Inner')
    cassini_outer = plt.Circle((0, 0), CASSINI_OUTER_R, color=CASSINI_COLOR,
                               fill=False, linestyle='--', linewidth=0.8, label='Cassini Div. Outer')
    resonance_2_1 = plt.Circle((0, 0), RESONANCE_2_1_R, color=RESONANCE_COLOR,
                               fill=False, linestyle='-.', linewidth=1.0, label='2:1 Resonance')

    # Add the patches to the axes
    ax.add_patch(saturn)
    ax.add_patch(mimas_orbit)
    ax.add_patch(cassini_inner)
    ax.add_patch(cassini_outer)
    ax.add_patch(resonance_2_1)

def main():
    """
    Main function to load data, set up the plot, create and display/save the animation.
    """
    # --- Data Loading and Parsing ---
    data = load_data(INPUT_FILENAME)
    time_data, particle_data, num_particles = parse_data(data)
    num_frames = len(time_data) # Number of animation frames corresponds to time steps

    # --- Plot Setup ---
    fig, ax = plt.subplots(figsize=(10, 10)) # Create figure and axes objects
    fig.patch.set_facecolor(FIGURE_BG_COLOR) # Set figure background color
    ax.set_facecolor(AXES_BG_COLOR)         # Set axes background color

    # Set plot appearance
    ax.set_aspect('equal', adjustable='box') # Ensure equal scaling for x and y axes
    ax.set_xlim(-PLOT_LIMIT, PLOT_LIMIT)     # Set x-axis limits
    ax.set_ylim(-PLOT_LIMIT, PLOT_LIMIT)     # Set y-axis limits
    ax.set_xlabel("X Position (m)", color=TEXT_COLOR) # X-axis label
    ax.set_ylabel("Y Position (m)", color=TEXT_COLOR) # Y-axis label
    ax.set_title("Cassini Division Clearing Simulation", color=TEXT_COLOR) # Plot title

    # Customize tick and spine colors for dark background
    ax.tick_params(axis='x', colors=TEXT_COLOR)
    ax.tick_params(axis='y', colors=TEXT_COLOR)
    for spine in ax.spines.values():
        spine.set_edgecolor(TEXT_COLOR)

    # --- Plot Static Elements ---
    plot_reference_circles(ax) # Add Saturn, Mimas orbit, Cassini, resonance circles

    # --- Initialize Scatter Plot for Particles ---
    # Get initial positions for coloring and setup
    initial_positions = particle_data[0, :, :]
    # Calculate initial radii to color particles
    initial_radii = np.sqrt(initial_positions[:, 0]**2 + initial_positions[:, 1]**2)
    # Normalize initial radii for the colormap
    norm = mcolors.Normalize(vmin=initial_radii.min(), vmax=initial_radii.max())
    cmap = plt.cm.plasma # Choose a colormap (e.g., plasma, viridis, magma)

    # Create the scatter plot object - positions will be updated in the animation
    scatter = ax.scatter(
        initial_positions[:, 0], initial_positions[:, 1], # Initial data
        s=PARTICLE_SIZE,         # Marker size
        c=initial_radii,         # Color based on initial radius
        cmap=cmap,               # Colormap to use
        norm=norm,               # Normalization for colors
        alpha=0.7                # Transparency
    )

    # --- Add Colorbar and Legend ---
    # Add a colorbar indicating the initial radius scale
    cbar = fig.colorbar(scatter, ax=ax, fraction=0.046, pad=0.04)
    cbar.set_label('Initial Radius (m)', color=TEXT_COLOR)
    cbar.ax.yaxis.set_tick_params(color=TEXT_COLOR) # Colorbar tick color
    plt.setp(plt.getp(cbar.ax.axes, 'yticklabels'), color=TEXT_COLOR) # Colorbar tick label color

    # Add text element to display the current simulation time
    time_text = ax.text(0.02, 0.98, '', transform=ax.transAxes, color=TEXT_COLOR,
                        ha='left', va='top', fontsize=10)

    # Add legend for the reference circles
    ax.legend(loc='upper right', fontsize='x-small', facecolor='darkslategrey',
              labelcolor='white', framealpha=0.7)

    # --- Animation Update Function ---
    def update(frame):
        """
        Updates the scatter plot data and time text for each animation frame.

        Args:
            frame (int): The current frame number provided by FuncAnimation.

        Returns:
            tuple: A tuple of mutable plot elements that were updated (for blitting).
        """
        # Get particle positions for the current frame
        current_positions = particle_data[frame, :, :]
        # Update the positions of the points in the scatter plot
        scatter.set_offsets(current_positions)

        # Calculate and display time in terms of Mimas orbits for context
        mimas_period_s = (2 * np.pi) / np.sqrt(G * (5.683e26 + 3.75e19) / (1.85539e8**3))
        time_in_orbits = time_data[frame] / mimas_period_s
        time_text.set_text(f'Time: {time_in_orbits:.2f} Mimas Orbits')

        # Return the updated plot elements for efficient redrawing (blitting)
        return scatter, time_text,

    # --- Create and Run Animation ---
    # Calculate interval between frames in milliseconds to achieve target duration
    interval_ms = max(1, int((TARGET_ANIMATION_DURATION_S * 1000) / num_frames))
    print(f"Setting up animation with {num_frames} frames at interval {interval_ms} ms.")

    # Create the animation object
    ani = animation.FuncAnimation(
        fig=fig,              # The figure to animate
        func=update,          # The function to call for each frame update
        frames=num_frames,    # Total number of frames
        interval=interval_ms, # Delay between frames in ms
        blit=True,            # Use blitting for performance optimization
        repeat=False          # Do not repeat the animation
    )

    # Adjust layout and display the animation
    plt.tight_layout(rect=[0, 0, 1, 0.96])
    plt.show()

    # --- Save Animation ---
    if SAVE_ANIMATION:
        try:
            print(f"Saving animation to '{MP4_FILENAME}'... (this may take time)")
            # Use ffmpeg writer to save as MP4
            ani.save(MP4_FILENAME, writer='ffmpeg', fps=30, dpi=200,
                     progress_callback=lambda i, n: print(f'Saving frame {i+1}/{n}', end='\r', flush=True)) # Show progress
            print(f"\nAnimation saved successfully to '{MP4_FILENAME}'.")
        except Exception as e:
            print(f"\nError saving animation: {e}")

# --- Main Execution Guard ---
if __name__ == "__main__":
    # This ensures the main function runs only when the script is executed directly
    main()